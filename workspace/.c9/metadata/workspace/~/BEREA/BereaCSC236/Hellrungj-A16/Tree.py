{"changed":true,"filter":false,"title":"Tree.py","tooltip":"~/BEREA/BereaCSC236/Hellrungj-A16/Tree.py","value":"#-------------------------------------------------------------------------------\n# Name:        BinarySearchTree.py\n# Purpose:  CSC 236 Example of creating and using binary search trees in Python.\n#\n#   Shows how to use a tree to store information, and in particular how to\n#   search through a binary search tree. This program both creates a binary\n#   search tree given an array, searches the tree given a target value, and\n#   deletes the tree before the program ends.\n#\n#-------------------------------------------------------------------------------\n# Put the definition of the Node structure after this line.\nclass Node():\n    def __str__(self):\n        \"\"\"Constructs a Node.\"\"\"\n        self.Notedata = 0\n        self.NodeleftLink = 0 #link is a pointer to another Node\n        self.NoderightLink = 0\n# Put the definition of the three recursive functions after this line.\n\ndef populate_from_array(currentNode, numbers, arraySize):\n    \"\"\"precondition: arraySize accurately states the number of items in numbers,\n        numbers refers to an allocated space for storing numbers,\n        thisNode points to an existing node (and not some random point in memory)\n    postcondition: thisNode will point to a tree that has as its children\n        and leaves the balanced binary search tree with values from numbers.\"\"\"\n\n    index = arraySize/2    # bifurcate the list to call this function recursively\n    value = numbers[index] # have the value at the middle of the array as the value of of this node, and then work on the left and right subtree.\n\n    assert( currentNode != None ) # There is something REALLY wrong if this node is NULL.\n\n    # BASE CASE: There is only one element, so it is a leaf!\n    currentNode.Notedata = numbers[index]\n    currentNode.NodeleftLink = None  # Make sure that this leaf points to nothing.\n    currentNode.NoderightLink = None  # Make sure that this leaf points to nothing.\n    if arraySize == 1:\n        return\n    currentNode.NodeleftLink = Node()\n    leftArray = index\n    for i in index:\n        leftArray[i] = numbers[i]\n    populate_from_array(currentNode.NodeleftLink, leftArray, index)\n    del leftArray   \n    \n    currentNode.NoderightLink = arraySize - index - 1\n    rightSize = arraySize - index - 1\n    if rightSize == 0: \n        return \n\n    currentNode.NoderightLink = Node()\n    rightArray = rightSize\n    index = 0\n    for i in arraySize:\n        rightArray[i-(index+1)] = numbers[i]\n        index=+1\n    populate_from_array(currentNode.NoderightLink, rightArray, rightSize)\n    del rightArray \n    # Put the driver function definition; i.e. main() after this line\n\ndef find_value( currentNode, targetValue ):\n    \"\"\"precondition: currentNode is either pointing to a valid tree node or\n        is NULL\n    postcondition: the tree rooted at currentNode has been deallocated.\"\"\"\n    # BASE CASE 1: The value is not in the tree, so we \"fell off\"\n    if currentNode == None:\n        return False\n    # BASE CASE 2: The value is found, so STOP LOOKING!\n    elif currentNode.data == targetValue:\n        return True\n\n    # RECURSION: Depending on the value, travel to the right or left.\n    if targetValue < currentNode.data:\n        return find_value( currentNode.NodeleftLink, targetValue )\n    else:\n        return find_value( currentNode.NoderightLink, targetValue )\n    #Recursively delete the tree (deallocate all the nodes)\ndef delete_node( currentNode ):\n\n    # BASE CASE: Reached beyond the leaf, must return to\n    # delete it.\n    if( currentNode == None ):\n        return\n    # RECURSION: Make sure that the children are gone first before\n    # this node is deleted.\n    if currentNode.NodeleftLink != None:\n        delete_node( currentNode.NodeleftLink )\n    if currentNode.NoderightLink != None:\n        delete_node( currentNode.NoderightLink )\n    #We only get here when both children are gone, so it is a leaf. DELETE!\n    del currentNode\n    delete_node(Node)\n    return 0\n\ndef main():\n    \"\"\"This main function calls the function to create a tree.\"\"\"\n    numItems = 7\n    numberList = [None]*numItems #This is how you fix it.\n    searchValue = 0\n    #create an array of the sequence 0 followed by 6 even numbers\n    for i in numItems:\n        numberList[i] = i*2;\n    #create the root node and then the entire tree, rooted at the root.\n    rootNode = Node()\n    populate_from_array( rootNode, numberList, numItems)\n\n    #ask the user for a value to find in the tree, then search for it.\n    searchValue = input(\"value to find? \")\n    if find_value( rootNode, searchValue ):\n        print(\"Found \" + str(searchValue))\n    else:\n        print ( str(searchValue) + \" is not in the tree!\") \n\nif __name__ == '__main__':\n    main()\n","undoManager":{"mark":0,"position":-1,"stack":[]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":0,"column":0},"end":{"row":0,"column":0},"isBackwards":true},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1415024996000}